
<!DOCTYPE html>


<html lang="en" data-content_root="./" data-theme="light">

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>PDEP-14: Dedicated string data type for pandas 3.0 &#8212; Pandas Enhancement Proposals  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "light";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=5b4479735964841361fd" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=5b4479735964841361fd" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=5b4479735964841361fd" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=5b4479735964841361fd" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="_static/pandas.css?v=cd9ee792" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=5b4479735964841361fd" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=5b4479735964841361fd" />
  <script src="_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=5b4479735964841361fd"></script>

    <script src="_static/documentation_options.js?v=5929fcd5"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '0014-string-dtype';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="light">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
<header>
  <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
  <div class="container">
  <a class="navbar-brand" href="../."><img alt="" src="../static/img/pandas_white.svg"></a>
  <div class="navbar-collapse collapse" id="nav-content">
    <ul class="navbar-nav ms-auto">
      <li class="nav-item">
          <a class="nav-link" href="../about/roadmap.html">Back to the PDEP index</a>
      </li>
    </ul>
  </div>
  </div>
  </nav>
  </header>

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          <div class="navbar-item">
<nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="0001-purpose-and-guidelines.html">
                        PDEP-1: Purpose and guidelines
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="0004-consistent-to-datetime-parsing.html">
                        PDEP-4: Consistent datetime parsing
                      </a>
                    </li>
                
  </ul>
</nav></div>
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article"></div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section id="pdep-14-dedicated-string-data-type-for-pandas-3-0">
<h1>PDEP-14: Dedicated string data type for pandas 3.0<a class="headerlink" href="#pdep-14-dedicated-string-data-type-for-pandas-3-0" title="Link to this heading">#</a></h1>
<ul class="simple">
<li><p>Created: May 3, 2024</p></li>
<li><p>Status: Under discussion</p></li>
<li><p>Discussion: <a class="github reference external" href="https://github.com/pandas-dev/pandas/pull/58551">pandas-dev/pandas#58551</a></p></li>
<li><p>Author: <a class="reference external" href="https://github.com/jorisvandenbossche">Joris Van den Bossche</a></p></li>
<li><p>Revision: 1</p></li>
</ul>
<section id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="Link to this heading">#</a></h2>
<p>This PDEP proposes to introduce a dedicated string dtype that will be used by
default in pandas 3.0:</p>
<ul class="simple">
<li><p>In pandas 3.0, enable a “string” dtype by default, using PyArrow if available
or otherwise a string dtype using numpy object-dtype under the hood as fallback.</p></li>
<li><p>The default string dtype will use missing value semantics (using NaN) consistent
with the other default data types.</p></li>
</ul>
<p>This will give users a long-awaited proper string dtype for 3.0, while 1) not
(yet) making PyArrow a <em>hard</em> dependency, but only a dependency used by default,
and 2) leaving room for future improvements (different missing value semantics,
using NumPy 2.0 strings, etc).</p>
</section>
<section id="background">
<h2>Background<a class="headerlink" href="#background" title="Link to this heading">#</a></h2>
<p>Currently, pandas by default stores text data in an <code class="docutils literal notranslate"><span class="pre">object</span></code>-dtype NumPy array.
The current implementation has two primary drawbacks. First, <code class="docutils literal notranslate"><span class="pre">object</span></code> dtype is
not specific to strings: any Python object can be stored in an <code class="docutils literal notranslate"><span class="pre">object</span></code>-dtype
array, not just strings, and seeing <code class="docutils literal notranslate"><span class="pre">object</span></code> as the dtype for a column with
strings is confusing for users. Second: this is not efficient (all string
methods on a Series are eventually calling Python methods on the individual
string objects).</p>
<p>To solve the first issue, a dedicated extension dtype for string data has
already been
<a class="reference external" href="https://pandas.pydata.org/docs/whatsnew/v1.0.0.html#dedicated-string-data-type">added in pandas 1.0</a>.
This has always been opt-in for now, requiring users to explicitly request the
dtype (with <code class="docutils literal notranslate"><span class="pre">dtype=&quot;string&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">dtype=pd.StringDtype()</span></code>). The array backing
this string dtype was initially almost the same as the default implementation,
i.e. an <code class="docutils literal notranslate"><span class="pre">object</span></code>-dtype NumPy array of Python strings.</p>
<p>To solve the second issue (performance), pandas contributed to the development
of string kernels in the PyArrow package, and a variant of the string dtype
backed by PyArrow was
<a class="reference external" href="https://pandas.pydata.org/docs/whatsnew/v1.3.0.html#pyarrow-backed-string-data-type">added in pandas 1.3</a>.
This could be specified with the <code class="docutils literal notranslate"><span class="pre">storage</span></code> keyword in the opt-in string dtype
(<code class="docutils literal notranslate"><span class="pre">pd.StringDtype(storage=&quot;pyarrow&quot;)</span></code>).</p>
<p>Since its introduction, the <code class="docutils literal notranslate"><span class="pre">StringDtype</span></code> has always been opt-in, and has used
the experimental <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> sentinel for missing values (which was also <a class="reference external" href="https://pandas.pydata.org/docs/whatsnew/v1.0.0.html#experimental-na-scalar-to-denote-missing-values">introduced
in pandas 1.0</a>).
However, up to this date, pandas has not yet taken the step to use <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> by
default for any dtype, and thus the <code class="docutils literal notranslate"><span class="pre">StringDtype</span></code> deviates in missing value behaviour compared
to the default data types.</p>
<p>In 2023, <a class="reference external" href="https://pandas.pydata.org/pdeps/0010-required-pyarrow-dependency.html">PDEP-10</a>
proposed to start using a PyArrow-backed string dtype by default in pandas 3.0
(i.e. infer this type for string data instead of object dtype). To ensure we
could use the variant of <code class="docutils literal notranslate"><span class="pre">StringDtype</span></code> backed by PyArrow instead of Python
objects (for better performance), it proposed to make <code class="docutils literal notranslate"><span class="pre">pyarrow</span></code> a new required
runtime dependency of pandas.</p>
<p>In the meantime, NumPy has also been working on a native variable-width string
data type, which will be available <a class="reference external" href="https://numpy.org/devdocs/release/2.0.0-notes.html#stringdtype-has-been-added-to-numpy">starting with NumPy
2.0</a>.
This can provide a potential alternative to PyArrow for implementing a string
data type in pandas that is not backed by Python objects.</p>
<p>After acceptance of PDEP-10, two aspects of the proposal have been under
reconsideration:</p>
<ul class="simple">
<li><p>Based on feedback from users and maintainers from other packages (mostly
around installation complexity and size), it has been considered to relax the
new <code class="docutils literal notranslate"><span class="pre">pyarrow</span></code> requirement to not be a <em>hard</em> runtime dependency. In addition,
NumPy 2.0 could in the future potentially reduce the need to make PyArrow a
required dependency specifically for a dedicated pandas string dtype.</p></li>
<li><p>PDEP-10 did not consider the usage of the experimental <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> as a
consequence of adopting one of the existing implementations of the
<code class="docutils literal notranslate"><span class="pre">StringDtype</span></code>.</p></li>
</ul>
<p>For the second aspect, another variant of the <code class="docutils literal notranslate"><span class="pre">StringDtype</span></code> was
<a class="reference external" href="https://pandas.pydata.org/docs/whatsnew/v2.1.0.html#whatsnew-210-enhancements-infer-strings">introduced in pandas 2.1</a>
that is still backed by PyArrow but follows the default missing values semantics
pandas uses for all other default data types (and using <code class="docutils literal notranslate"><span class="pre">NaN</span></code> as the missing
value sentinel) (<a class="reference external" href="https://github.com/pandas-dev/pandas/issues/54792">GH-54792</a>).
At the time, the <code class="docutils literal notranslate"><span class="pre">storage</span></code> option for this new variant was called
<code class="docutils literal notranslate"><span class="pre">&quot;pyarrow_numpy&quot;</span></code> to disambiguate from the existing <code class="docutils literal notranslate"><span class="pre">&quot;pyarrow&quot;</span></code> option using
<code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> (but this PDEP proposes a better naming scheme, see the “Naming”
subsection below).</p>
<p>This last dtype variant is what users currently (pandas 2.2) get for string data
when enabling the <code class="docutils literal notranslate"><span class="pre">future.infer_string</span></code> option (to enable the behaviour which
is intended to become the default in pandas 3.0).</p>
</section>
<section id="proposal">
<h2>Proposal<a class="headerlink" href="#proposal" title="Link to this heading">#</a></h2>
<p>To be able to move forward with a string data type in pandas 3.0, this PDEP proposes:</p>
<ol class="arabic simple">
<li><p>For pandas 3.0,  a “string” dtype is enabled by default, which will use PyArrow
if installed, and otherwise falls back to an in-house functionally-equivalent
(but slower) version.</p></li>
<li><p>This default “string” dtype will follow the same behaviour for missing values
as other default data types, and use <code class="docutils literal notranslate"><span class="pre">NaN</span></code> as the missing value sentinel.</p></li>
<li><p>The version that is not backed by PyArrow can reuse (with minor code
additions) the existing numpy object-dtype backed StringArray for its
implementation.</p></li>
<li><p>Installation guidelines are updated to clearly encourage users to install
pyarrow for the default user experience.</p></li>
</ol>
<p>Those string dtypes enabled by default will then no longer be considered as
experimental.</p>
<section id="default-inference-of-a-string-dtype">
<h3>Default inference of a string dtype<a class="headerlink" href="#default-inference-of-a-string-dtype" title="Link to this heading">#</a></h3>
<p>By default, pandas will infer this new string dtype instead of object dtype for
string data (when creating pandas objects, such as in constructors or IO
functions).</p>
<p>In pandas 2.2, the existing <code class="docutils literal notranslate"><span class="pre">future.infer_string</span></code> option can be used to opt-in to the future
default behaviour:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">future</span><span class="o">.</span><span class="n">infer_string</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="go">0      a</span>
<span class="go">1      b</span>
<span class="go">2    NaN</span>
<span class="go">dtype: string</span>
</pre></div>
</div>
<p>Right now (pandas 2.2), the existing option only enables the PyArrow-based
future dtype. For the remaining 2.x releases, this option will be expanded to
also work when PyArrow is not installed to enable the object-dtype fallback in
that case.</p>
</section>
<section id="missing-value-semantics">
<h3>Missing value semantics<a class="headerlink" href="#missing-value-semantics" title="Link to this heading">#</a></h3>
<p>As mentioned in the background section, the original <code class="docutils literal notranslate"><span class="pre">StringDtype</span></code> has used
the experimental <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> sentinel for missing values. In addition to using
<code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> as the scalar for a missing value, this essentially means
that:</p>
<ul class="simple">
<li><p>String columns follow <a class="reference external" href="https://pandas.pydata.org/docs/user_guide/missing_data.html#na-semantics">“NA-semantics”</a>
for missing values, where <code class="docutils literal notranslate"><span class="pre">NA</span></code> propagates in boolean operations such as
comparisons or predicates.</p></li>
<li><p>Operations on the string column that give a numeric or boolean result use the
nullable Integer/Float/Boolean data types (e.g. <code class="docutils literal notranslate"><span class="pre">ser.str.len()</span></code> returns the
nullable <code class="docutils literal notranslate"><span class="pre">'Int64&quot;</span></code> / <code class="docutils literal notranslate"><span class="pre">pd.Int64Dtype()</span></code> dtype instead of the numpy <code class="docutils literal notranslate"><span class="pre">int64</span></code>
dtype (or <code class="docutils literal notranslate"><span class="pre">float64</span></code> in case of missing values)).</p></li>
</ul>
<p>However, up to this date, all other default data types still use <code class="docutils literal notranslate"><span class="pre">NaN</span></code> semantics
for missing values. Therefore, this proposal says that a new default string
dtype should also still use the same default missing value semantics and return
default data types when doing operations on the string column, to be consistent
with the other default dtypes at this point.</p>
<p>In practice, this means that the default <code class="docutils literal notranslate"><span class="pre">&quot;string&quot;</span></code> dtype will use <code class="docutils literal notranslate"><span class="pre">NaN</span></code> as
the missing value sentinel, and:</p>
<ul class="simple">
<li><p>String columns will follow NaN-semantics for missing values, where <code class="docutils literal notranslate"><span class="pre">NaN</span></code> gives
False in boolean operations such as comparisons or predicates.</p></li>
<li><p>Operations on the string column that give a numeric or boolean result will use
the default data types (i.e. numpy <code class="docutils literal notranslate"><span class="pre">int64</span></code>/<code class="docutils literal notranslate"><span class="pre">float64</span></code>/<code class="docutils literal notranslate"><span class="pre">bool</span></code>).</p></li>
</ul>
<p>Because the original <code class="docutils literal notranslate"><span class="pre">StringDtype</span></code> implementations already use <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> and
return masked integer and boolean arrays in operations, a new variant of the
existing dtypes that uses <code class="docutils literal notranslate"><span class="pre">NaN</span></code> and default data types was needed. The original
variant of <code class="docutils literal notranslate"><span class="pre">StringDtype</span></code> using <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> will still be available for those who
want to keep using it (see below in the “Naming” subsection for how to specify
this).</p>
</section>
<section id="object-dtype-fallback-implementation">
<h3>Object-dtype “fallback” implementation<a class="headerlink" href="#object-dtype-fallback-implementation" title="Link to this heading">#</a></h3>
<p>To avoid a hard dependency on PyArrow for pandas 3.0, this PDEP proposes to keep
a “fallback” option in case PyArrow is not installed. The original <code class="docutils literal notranslate"><span class="pre">StringDtype</span></code>
backed by a numpy object-dtype array of Python strings can be mostly reused for
this (adding a new variant of the dtype) and a new <code class="docutils literal notranslate"><span class="pre">StringArray</span></code> subclass only
needs minor changes to follow the above-mentioned missing value semantics
(<a class="reference external" href="https://github.com/pandas-dev/pandas/pull/58451">GH-58451</a>).</p>
<p>For pandas 3.0, this is the most realistic option given this implementation has
already been available for a long time. Beyond 3.0, further improvements such as
using NumPy 2.0 (<a class="reference external" href="https://github.com/pandas-dev/pandas/issues/58503">GH-58503</a>)
or nanoarrow (<a class="reference external" href="https://github.com/pandas-dev/pandas/issues/58552">GH-58552</a>) can
still be explored, but at that point that is an implementation detail that
should not have a direct impact on users (except for performance).</p>
</section>
<section id="naming">
<h3>Naming<a class="headerlink" href="#naming" title="Link to this heading">#</a></h3>
<p>Given the long history of this topic, the naming of the dtypes is a difficult
topic.</p>
<p>In the first place, it should be acknowledged that most users should not need to
use storage-specific options. Users are expected to specify <code class="docutils literal notranslate"><span class="pre">pd.StringDtype()</span></code>
or <code class="docutils literal notranslate"><span class="pre">&quot;string&quot;</span></code>, and that will give them their default string dtype (which
depends on whether PyArrow is installed or not).</p>
<p>But for testing purposes and advanced use cases that want control over this, we
need some way to specify this and distinguish them from the other string dtypes.
In addition, users that want to continue using the original NA-variant of the
dtype need a way to specify this.</p>
<p>Currently (pandas 2.2), <code class="docutils literal notranslate"><span class="pre">StringDtype(storage=&quot;pyarrow_numpy&quot;)</span></code> is used, where
the <code class="docutils literal notranslate"><span class="pre">&quot;pyarrow_numpy&quot;</span></code> storage was used to disambiguate from the existing
<code class="docutils literal notranslate"><span class="pre">&quot;pyarrow&quot;</span></code> option using <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code>. However, <code class="docutils literal notranslate"><span class="pre">&quot;pyarrow_numpy&quot;</span></code> is a rather confusing
option and doesn’t generalize well. Therefore, this PDEP proposes a new naming
scheme as outlined below, and <code class="docutils literal notranslate"><span class="pre">&quot;pyarrow_numpy&quot;</span></code> will be deprecated and removed
before pandas 3.0.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">storage</span></code> keyword of <code class="docutils literal notranslate"><span class="pre">StringDtype</span></code> is kept to disambiguate the underlying
storage of the string data (using pyarrow or python objects), but an additional
<code class="docutils literal notranslate"><span class="pre">na_value</span></code> is introduced to disambiguate the the variants using NA semantics
and NaN semantics.</p>
<p>Overview of the different ways to specify a dtype and the resulting concrete
dtype of the data:</p>
<table class="table small" style="display: block;">
<thead>
<tr class="row-odd"><th class="head"><p>User specification</p></th>
<th class="head"><p>Concrete dtype</p></th>
<th class="head"><p>String alias</p></th>
<th class="head"><p>Note</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Unspecified (inference)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">StringDtype(storage=&quot;pyarrow&quot;|&quot;python&quot;,</span> <span class="pre">na_value=np.nan)</span></code></p></td>
<td><p>“string”</p></td>
<td><p>(1)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">StringDtype()</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;string&quot;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">StringDtype(storage=&quot;pyarrow&quot;</span> <span class="pre">|</span> <span class="pre">&quot;python&quot;,</span> <span class="pre">na_value=np.nan)</span></code></p></td>
<td><p>“string”</p></td>
<td><p>(1), (2)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">StringDtype(&quot;pyarrow&quot;)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">StringDtype(storage=&quot;pyarrow&quot;,</span> <span class="pre">na_value=np.nan)</span></code></p></td>
<td><p>“string”</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">StringDtype(&quot;python&quot;)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">StringDtype(storage=&quot;python&quot;,</span> <span class="pre">na_value=np.nan)</span></code></p></td>
<td><p>“string”</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">StringDtype(&quot;pyarrow&quot;,</span> <span class="pre">na_value=pd.NA)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">StringDtype(storage=&quot;pyarrow&quot;,</span> <span class="pre">na_value=pd.NA)</span></code></p></td>
<td><p>“String[pyarrow]”</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">StringDtype(&quot;python&quot;,</span> <span class="pre">na_value=pd.NA)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">StringDtype(storage=&quot;python&quot;,</span> <span class="pre">na_value=pd.NA)</span></code></p></td>
<td><p>“String[python]”</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">StringDtype(na_value=pd.NA)</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;String&quot;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">StringDtype(storage=&quot;pyarrow&quot;</span> <span class="pre">|</span> <span class="pre">&quot;python&quot;,</span> <span class="pre">na_value=pd.NA)</span></code></p></td>
<td><p>“String[pyarrow]” or “String[python]”</p></td>
<td><p>(1)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">StringDtype(&quot;pyarrow_numpy&quot;)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">StringDtype(storage=&quot;pyarrow&quot;,</span> <span class="pre">na_value=np.nan)</span></code></p></td>
<td><p>“string[pyarrow_numpy]”</p></td>
<td><p>(3)</p></td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ul class="simple">
<li><p>(1) You get “pyarrow” or “python” depending on pyarrow being installed.</p></li>
<li><p>(2) Those three rows are backwards incompatible (i.e. they work now but give
the NA-variant), see the “Backward compatibility” section below.</p></li>
<li><p>(3) “pyarrow_numpy” is kept temporarily because this is already in a released
version, but we can deprecate it in 2.x and have it removed for 3.0.</p></li>
</ul>
<p>For the new default string dtype, only the <code class="docutils literal notranslate"><span class="pre">&quot;string&quot;</span></code> alias can be used to
specify the dtype as a string, i.e. a way would not be provided to make the
underlying storage (pyarrow or python) explicit through the string alias. This
string alias is only a convenience shortcut and for most users <code class="docutils literal notranslate"><span class="pre">&quot;string&quot;</span></code> is
sufficient (they don’t need to specify the storage), and the explicit
<code class="docutils literal notranslate"><span class="pre">pd.StringDtype(...)</span></code> is still available for more fine-grained control.</p>
</section>
</section>
<section id="alternatives">
<h2>Alternatives<a class="headerlink" href="#alternatives" title="Link to this heading">#</a></h2>
<section id="why-not-delay-introducing-a-default-string-dtype">
<h3>Why not delay introducing a default string dtype?<a class="headerlink" href="#why-not-delay-introducing-a-default-string-dtype" title="Link to this heading">#</a></h3>
<p>To avoid introducing a new string dtype while other discussions and changes are
in flux (eventually making pyarrow a required dependency? adopting <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> as
the default missing value sentinel? using the new NumPy 2.0 capabilities?
overhauling all our dtypes to use a logical data type system?), introducing a
default string dtype could also be delayed until there is more clarity in those
other discussions. Specifically, it would avoid temporarily switching to use
<code class="docutils literal notranslate"><span class="pre">NaN</span></code> for the string dtype, while in a future version we might switch back
to <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> by default.</p>
<p>However:</p>
<ol class="arabic simple">
<li><p>Delaying has a cost: it further postpones introducing a dedicated string
dtype that has massive benefits for users, both in usability as (for the
part of the user base that has PyArrow installed) in performance.</p></li>
<li><p>In case pandas eventually transitions to use <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> as the default missing value
sentinel,  a migration path for <em>all</em> pandas data types will be needed, and thus
the challenges around this will not be unique to the string dtype and
therefore not a reason to delay this.</p></li>
</ol>
<p>Making this change now for 3.0 will benefit the majority of users, while coming
at a cost for a part of the users who already started using the <code class="docutils literal notranslate"><span class="pre">&quot;string&quot;</span></code> or
<code class="docutils literal notranslate"><span class="pre">pd.StringDtype()</span></code> dtype (they will have to update their code to continue to use
the variant using <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code>, see the “Backward compatibility” section below).</p>
</section>
<section id="why-not-use-the-existing-stringdtype-with-pd-na">
<h3>Why not use the existing StringDtype with <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code>?<a class="headerlink" href="#why-not-use-the-existing-stringdtype-with-pd-na" title="Link to this heading">#</a></h3>
<p>Wouldn’t adding even more variants of the string dtype make things only more
confusing? Indeed, this proposal unfortunately introduces more variants of the
string dtype. However, the reason for this is to ensure the actual default user
experience is <em>less</em> confusing, and the new string dtype fits better with the
other default data types.</p>
<p>If the new default string data type would use <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code>, then after some
operations, a user can easily end up with a DataFrame that mixes columns using
<code class="docutils literal notranslate"><span class="pre">NaN</span></code> semantics and columns using <code class="docutils literal notranslate"><span class="pre">NA</span></code> semantics (and thus a DataFrame that
could have columns with two different int64, two different float64, two different
bool, etc dtypes). This would lead to a very confusing default experience.</p>
<p>With the proposed new variant of the StringDtype, this will ensure that for the
<em>default</em> experience, a user will only see only 1 kind of integer dtype, only
kind of 1 bool dtype, etc. For now, a user should only get columns using <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code>
when explicitly opting into this.</p>
</section>
<section id="naming-alternatives">
<h3>Naming alternatives<a class="headerlink" href="#naming-alternatives" title="Link to this heading">#</a></h3>
<p>This PDEP now keeps the <code class="docutils literal notranslate"><span class="pre">pd.StringDtype</span></code> class constructor with the existing
<code class="docutils literal notranslate"><span class="pre">storage</span></code> keyword and with an additional <code class="docutils literal notranslate"><span class="pre">na_value</span></code> keyword.</p>
<p>During the discussion, several alternatives have been brought up. Both
alternative keyword names as using a different constructor. This PDEP opted to
keep using the existing <code class="docutils literal notranslate"><span class="pre">pd.StringDtype()</span></code> for now to keep the changes as
minimal as possible, leaving a larger overhaul of the dtype system (potentially
including different constructor functions or namespace) for a future discussion.
See <a class="reference external" href="https://github.com/pandas-dev/pandas/issues/58613">GH-58613</a> for the full
discussion.</p>
</section>
</section>
<section id="backward-compatibility">
<h2>Backward compatibility<a class="headerlink" href="#backward-compatibility" title="Link to this heading">#</a></h2>
<p>The most visible backwards incompatible change will be that columns with string
data will no longer have an <code class="docutils literal notranslate"><span class="pre">object</span></code> dtype. Therefore, code that assumes
<code class="docutils literal notranslate"><span class="pre">object</span></code> dtype (such as <code class="docutils literal notranslate"><span class="pre">ser.dtype</span> <span class="pre">==</span> <span class="pre">object</span></code>) will need to be updated. This
change is done as a hard break in a major release, as warning in advance for the
changed inference is deemed too noisy.</p>
<p>To allow testing code in advance, the
<code class="docutils literal notranslate"><span class="pre">pd.options.future.infer_string</span> <span class="pre">=</span> <span class="pre">True</span></code> option is available for users.</p>
<p>Otherwise, the actual string-specific functionality (such as the <code class="docutils literal notranslate"><span class="pre">.str</span></code> accessor
methods) should generally all keep working as is.</p>
<p>By preserving the current missing value semantics, this proposal is also mostly
backwards compatible on this aspect. When storing strings in object dtype, pandas
however did allow using <code class="docutils literal notranslate"><span class="pre">None</span></code> as the missing value indicator as well (and in
certain cases such as the <code class="docutils literal notranslate"><span class="pre">shift</span></code> method, pandas even introduced this itself).
For all the cases where currently <code class="docutils literal notranslate"><span class="pre">None</span></code> was used as the missing value sentinel,
this will change to use <code class="docutils literal notranslate"><span class="pre">NaN</span></code> consistently.</p>
<section id="for-existing-users-of-stringdtype">
<h3>For existing users of <code class="docutils literal notranslate"><span class="pre">StringDtype</span></code><a class="headerlink" href="#for-existing-users-of-stringdtype" title="Link to this heading">#</a></h3>
<p>Users of the existing <code class="docutils literal notranslate"><span class="pre">StringDtype</span></code> will see more backwards incompatible
changes, though. In pandas 3.0, calling <code class="docutils literal notranslate"><span class="pre">pd.StringDtype()</span></code> (or specifying
<code class="docutils literal notranslate"><span class="pre">dtype=&quot;string&quot;</span></code>) will start returning the new default string dtype using <code class="docutils literal notranslate"><span class="pre">NaN</span></code>,
while up to now this returned the string dtype using <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> introduced in
pandas 1.0.</p>
<p>For example, this code snippet returned the NA-variant of <code class="docutils literal notranslate"><span class="pre">StringDtype</span></code> with
pandas 1.x and 2.x:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;string&quot;</span><span class="p">)</span>
<span class="go">0      a</span>
<span class="go">1      b</span>
<span class="go">2   &lt;NA&gt;</span>
<span class="go">dtype: string</span>
</pre></div>
</div>
<p>but will start returning the new default NaN-variant of <code class="docutils literal notranslate"><span class="pre">StringDtype</span></code> with
pandas 3.0. This means that the missing value sentinel will change from <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code>
to <code class="docutils literal notranslate"><span class="pre">NaN</span></code>, and that operations will no longer return nullable dtypes but default
numpy dtypes (see the “Missing value semantics” section above).</p>
<p>While this change will be transparent in many cases (e.g. checking for missing
values with <code class="docutils literal notranslate"><span class="pre">isna()</span></code>/<code class="docutils literal notranslate"><span class="pre">dropna()</span></code>/<code class="docutils literal notranslate"><span class="pre">fillna()</span></code> or filtering rows with the result of
a string predicate method keeps working regardless of the sentinel), this can be
a breaking change if users relied on the exact sentinel or resulting dtype. Since
pandas 1.0, the string dtype has been promoted quite a bit, and so we expect
that many users already have started using this dtype, even though officially
still labeled as “experimental”.</p>
<p>To smooth the upgrade experience for those users, it is proposed to add a
deprecation warning before 3.0 when such dtype is created, giving them two
options:</p>
<ul class="simple">
<li><p>If the user just wants to have a dedicated “string” dtype (or the better
performance when using pyarrow) but is fine with using the default NaN
semantics, they can add <code class="docutils literal notranslate"><span class="pre">pd.options.future.infer_string</span> <span class="pre">=</span> <span class="pre">True</span></code> to their code
to suppress the warning and already opt-in to the future behaviour of pandas
3.0.</p></li>
<li><p>If the user specifically wants the variant of the string dtype that uses
<code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> (and returns nullable numeric/boolean dtypes in operations), they will
have to update their dtype specification from <code class="docutils literal notranslate"><span class="pre">&quot;string&quot;</span></code> / <code class="docutils literal notranslate"><span class="pre">pd.StringDtype()</span></code>
to <code class="docutils literal notranslate"><span class="pre">&quot;String&quot;</span></code> / <code class="docutils literal notranslate"><span class="pre">pd.StringDtype(na_value=pd.NA)</span></code> to suppress the warning and
further keep their code running as is.</p></li>
</ul>
<p>A <code class="docutils literal notranslate"><span class="pre">&quot;String&quot;</span></code> alias (capitalized) would be added to make it easier for users to
continue using the variant using <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code>, and such capitalized string alias is
consistent with other nullable dtypes (<code class="docutils literal notranslate"><span class="pre">&quot;float64</span></code>” vs <code class="docutils literal notranslate"><span class="pre">&quot;Float64&quot;</span></code>).</p>
</section>
</section>
<section id="timeline">
<h2>Timeline<a class="headerlink" href="#timeline" title="Link to this heading">#</a></h2>
<p>The future PyArrow-backed string dtype was already made available behind a feature
flag in pandas 2.1 (enabled by <code class="docutils literal notranslate"><span class="pre">pd.options.future.infer_string</span> <span class="pre">=</span> <span class="pre">True</span></code>).</p>
<p>The variant using numpy object-dtype can also be backported to the 2.2.x branch
to allow easier testing. It is proposed to release this as 2.3.0 (created from
the 2.2.x branch, given that the main branch already includes many other changes
targeted for 3.0), together with the deprecation warning when creating a dtype
from <code class="docutils literal notranslate"><span class="pre">&quot;string&quot;</span></code> / <code class="docutils literal notranslate"><span class="pre">pd.StringDtype()</span></code>.</p>
<p>The 2.3.0 release would then have all future string functionality available
(both the pyarrow and object-dtype based variants of the default string dtype),
and warn existing users of the <code class="docutils literal notranslate"><span class="pre">StringDtype</span></code> in advance of 3.0 about how to
update their code.</p>
<p>For pandas 3.0, this <code class="docutils literal notranslate"><span class="pre">future.infer_string</span></code> flag becomes enabled by default.</p>
</section>
<section id="pdep-xx-history">
<h2>PDEP-XX History<a class="headerlink" href="#pdep-xx-history" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>3 May 2024: Initial version</p></li>
</ul>
</section>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">

  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#abstract">Abstract</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#background">Background</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#proposal">Proposal</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#default-inference-of-a-string-dtype">Default inference of a string dtype</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#missing-value-semantics">Missing value semantics</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#object-dtype-fallback-implementation">Object-dtype “fallback” implementation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#naming">Naming</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#alternatives">Alternatives</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#why-not-delay-introducing-a-default-string-dtype">Why not delay introducing a default string dtype?</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#why-not-use-the-existing-stringdtype-with-pd-na">Why not use the existing StringDtype with <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code>?</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#naming-alternatives">Naming alternatives</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#backward-compatibility">Backward compatibility</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#for-existing-users-of-stringdtype">For existing users of <code class="docutils literal notranslate"><span class="pre">StringDtype</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#timeline">Timeline</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pdep-xx-history">PDEP-XX History</a></li>
</ul>
  </nav></div>

  <div class="sidebar-secondary-item">

  <div class="tocsection sourcelink">
    <a href="_sources/0014-string-dtype.md.txt">
      <i class="fa-solid fa-file-lines"></i> Show Source
    </a>
  </div>
</div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=5b4479735964841361fd"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=5b4479735964841361fd"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2023, Pandas.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.14.4.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>
